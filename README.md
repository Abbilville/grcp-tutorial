# Tutorial-9
---
#### Nama: Abbilhaidar Farras Zulfikar
#### NPM: 2206026012
#### Kelas: Adpro A
---
### Refleksi
1. **What are the key differences between unary, server streaming, and bi-directional streaming RPC (Remote Procedure Call) methods, and in what scenarios would each be most suitable?** <br>
- Unary RPC adalah ketika client mengirim satu request dan menunggu satu response dari server. Cocok digunakan untuk situasi di mana hanya satu permintaan diperlukan dan hanya satu respons yang diharapkan, misalnya pengiriman notifikasi email atau mengambil detail produk dari e-commerce.
- Server Streaming RPC terjadi ketika client mengirim satu request dan menerima beberapa response dari server. Cocok digunakan jika satu permintaan dapat menghasilkan banyak respons, seperti ketika melakukan pembaruan data berkala atau menonton playlist video.
- Bi-directional Streaming RPC terjadi ketika client dan server dapat saling mengirim beberapa permintaan dan respons secara bersamaan dan kontinyu. Cocok digunakan jika diperlukan interaksi yang saling bergantian antara client dan server dalam waktu nyata, seperti pada aplikasi yang memungkinkan pertukaran pesan real-time. <br>

2. **What are the potential security considerations involved in implementing a gRPC service in Rust, particularly regarding authentication, authorization, and data encryption?** <br>
Dalam implementasi gRPC menggunakan Rust, terdapat beberapa pertimbangan keamanan yang perlu diperhatikan, seperti autentikasi, otorisasi, dan enkripsi data. Autentikasi diperlukan untuk memastikan bahwa hanya pengguna yang terotorisasi yang dapat terhubung ke server gRPC. Otorisasi digunakan untuk mengendalikan akses pengguna terhadap sumber daya tertentu. Enkripsi data penting untuk melindungi data sensitif dari pencurian selama transit. Penggunaan mekanisme autentikasi seperti JWT dapat membantu meningkatkan keamanan. <br>

3. **What are the potential challenges or issues that may arise when handling bidirectional streaming in Rust gRPC, especially in scenarios like chat applications?** <br>
Ketika menghadapi streaming bidirectional dalam Rust gRPC, khususnya dalam skenario seperti chat application, beberapa challenges atau isu mungkin muncul. Pengelolaan masa pakai dari stream bisa menjadi kompleks, terutama ketika menangani beberapa stream bersamaan. Penting untuk memastikan bahwa stream ditutup dan dibersihkan dengan benar untuk menghindari kebocoran memori dan kelelahan sumber daya. Penanganan kesalahan yang terjadi selama operasi streaming juga penting untuk menjaga stabilitas dan keandalan aplikasi. Ini termasuk penanganan kesalahan jaringan, kesalahan dalam serialisasi/deserialisasi, dan kesalahan khusus aplikasi dengan lemah lembut. Menjaga keamanan komunikasi streaming bidirectional sangat penting, terutama dalam aplikasi obrolan di mana informasi sensitif mungkin pertukaran. Implementasi mekanisme autentikasi, otorisasi, dan enkripsi untuk melindungi terhadap akses tidak sah dan pelanggaran data sangat diperlukan. <br>

4. **What are the advantages and disadvantages of using the tokio_stream::wrappers::ReceiverStream for streaming responses in Rust gRPC services?** <br>
advantages menggunakan <code>tokio_stream::wrappers::ReceiverStream</code> untuk streaming respons dalam layanan Rust gRPC meliputi kompatibilitas dengan Tokio yang memungkinkan integrasi yang mulus dan optimal antara ReceiverStream dan Tokio. Selain itu, kemampuan ReceiverStream untuk mengonsumsi data secara asinkron memungkinkan sinkronisasi yang efisien dalam penanganan aliran data. Keuntungan lainnya adalah pengurangan kompleksitas kode dan percepatan dalam pengembangan aplikasi, yang pada gilirannya dapat meningkatkan maintainability aplikasi. <br>
Namun, terdapat beberapa disadvantages yang perlu diperhatikan. Salah satunya adalah bahwa ReceiverStream tidak terintegrasi secara langsung dengan gRPC, yang dapat mengakibatkan kesulitan dalam mengintegrasikannya dengan layanan gRPC. Meskipun integrasinya dengan Tokio berjalan lancar, memerlukan upaya tambahan untuk mengintegrasikannya dengan gRPC. Selain itu, ada keterbatasan fungsionalitas tertentu yang perlu dipertimbangkan karena tidak terintegrasi secara langsung dengan gRPC. <br>

5. **In what ways could the Rust gRPC code be structured to facilitate code reuse and modularity, promoting maintainability and extensibility over time?** <br>
Untuk meningkatkan reuse dan modularitas kode dalam Rust gRPC, dapat diterapkan pendekatan yang memisahkan concern pada logika bisnis untuk menjaga extensibilitas aplikasi. Ini memudahkan modifikasi pada bagian tertentu dan mempertahankan maintainability dalam jangka panjang. Selain itu, pembuatan modul atau pustaka bersama untuk kode yang serupa dapat membantu dalam refactoring modul. Memanfaatkan generic types juga memungkinkan fleksibilitas dalam menerima berbagai tipe data. Penggunaan pola desain seperti builder pattern untuk membangun objek kompleks dapat meningkatkan reuse dan modularitas, serta memaksimalkan maintainability dan extensibility dari kode Rust gRPC. <br>

6. **In the MyPaymentService implementation, what additional steps might be necessary to handle more complex payment processing logic?** <br>
Untuk mengatasi pemrosesan pembayaran yang lebih kompleks dalam implementasi MyPaymentService, langkah-langkah tambahan yang mungkin diperlukan termasuk melakukan validasi data untuk semua field yang diperlukan dan menentukan penanganan exception yang tepat untuk memastikan keamanan aplikasi dari berbagai serangan, seperti SQL injection dan cross-site scripting (XSS). Selain itu, akan diperlukan pengembangan program tambahan yang dapat mengirimkan notifikasi mengenai keberhasilan atau kegagalan pembayaran untuk memastikan pemilik aplikasi memiliki pemahaman yang jelas tentang status pembayaran dan dapat merespons dengan tepat terhadapnya. Hal ini penting karena keberhasilan atau kegagalan pembayaran dapat mempengaruhi langkah-langkah selanjutnya dalam proses bisnis atau transaksi yang terkait. <br>

7. **What impact does the adoption of gRPC as a communication protocol have on the overall architecture and design of distributed systems, particularly in terms of interoperability with other technologies and platforms?** <br>
Penggunaan gRPC sebagai protokol komunikasi memiliki dampak besar pada arsitektur dan desain sistem terdistribusi secara keseluruhan, terutama dalam hal interoperabilitas dengan teknologi dan platform lainnya. gRPC menggunakan HTTP/2 sebagai transport, yang menghadirkan komunikasi yang efisien dan memanfaatkan multiplexing antara klien dan server. Ini dapat meningkatkan kinerja sistem dengan mengurangi latency dan memanfaatkan sumber daya secara lebih efisien dibandingkan dengan penggunaan HTTP/1 atau API REST tradisional. Selain itu, gRPC bergantung pada Protocol Buffers (protobuf) untuk mendefinisikan layanan dan serialisasi pesan. Penggunaan protobuf memungkinkan definisi API yang independen terhadap bahasa pemrograman tertentu. Dengan demikian, adopsi gRPC mendorong interoperabilitas antar berbagai bahasa pemrograman, platform, dan teknologi. <br>

8. **What are the advantages and disadvantages of using HTTP/2, the underlying protocol for gRPC, compared to HTTP/1.1 or HTTP/1.1 with WebSocket for REST APIs?** <br>
Advantages menggunakan HTTP/2, yang merupakan protokol dasar untuk gRPC, dibandingkan dengan HTTP/1.1 atau HTTP/1.1 dengan WebSocket untuk REST API, adalah kemampuannya untuk mendukung multiplexing, yang memungkinkan pengiriman beberapa permintaan dan tanggapan dalam satu koneksi TCP. Selain itu, HTTP/2 juga mendukung server push, di mana server dapat mengirimkan data tanpa diminta oleh klien jika server memprediksi bahwa klien akan membutuhkannya. Hal ini mengoptimalkan penggunaan bandwidth, mengurangi waktu latensi untuk memproses permintaan, dan meningkatkan efisiensi dalam transfer data. <br>
Namun, terdapat beberapa Disadvantages dalam penggunaan HTTP/2. Salah satunya adalah bahwa belum semua server dan klien mendukung protokol HTTP/2, yang dapat menghasilkan masalah kompatibilitas dan memengaruhi fungsionalitas aplikasi. Selain itu, kompleksitas implementasinya juga meningkat karena konsep-konsep baru seperti multiplexing dan server push, yang mungkin memerlukan waktu lebih lama dalam pengembangan aplikasi. <br>

9. **How does the request-response model of REST APIs contrast with the bidirectional streaming capabilities of gRPC in terms of real-time communication and responsiveness?** <br>
REST API menggunakan model permintaan-respons yang cocok untuk interaksi klien-server tradisional, namun tidak optimal untuk komunikasi real-time karena terbatas pada satu arah. Sebaliknya, gRPC dengan streaming bidirectional sangat efisien untuk komunikasi real-time karena memungkinkan pertukaran data instan dan responsif dengan latency rendah. <br>
Sementara REST API memiliki overhead pada setiap permintaan HTTP, gRPC dengan streaming bidirectional memungkinkan interaksi real-time dan full-duplex, meskipun lebih kompleks dalam implementasinya dan dapat memengaruhi maintainability aplikasi. <br>
Pemilihan antara REST API dan gRPC harus mempertimbangkan latensi, kompleksitas, dan kebutuhan interaksi real-time. gRPC cocok untuk interaksi real-time, sementara REST API lebih sesuai untuk antarmuka sederhana dan konsisten. <br>

10. **What are the implications of the schema-based approach of gRPC, using Protocol Buffers, compared to the more flexible, schema-less nature of JSON in REST API payloads?** <br>
Menggunakan gRPC dengan Protocol Buffers menghadirkan keuntungan dalam mendefinisikan skema dan tipe data yang ketat, meningkatkan keamanan data, dan mengurangi risiko kesalahan karena definisinya yang ketat. Selain itu, penggunaan format biner dapat mengurangi payload dan meningkatkan kinerja transfer data. <br>
Di sisi lain, JSON memiliki fleksibilitas yang lebih besar dalam struktur data, cocok untuk tipe data yang dinamis. Meskipun demikian, kekurangan JSON adalah kurangnya keamanan dan kemungkinan kesalahan dalam definisi skema. <br>
Kelebihan JSON termasuk kemudahan dalam readability dan interoperabilitas lintas bahasa pemrograman dan platform karena sifatnya yang universal. Pemilihan antara gRPC dengan Protocol Buffers dan JSON harus mempertimbangkan prioritas aplikasi dan kebutuhan akan ketatnya definisi skema dan keamanan data. <br>
